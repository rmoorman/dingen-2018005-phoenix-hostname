# Objectives
Build a small example phoenix application which uses a dynamically configured
set of allowed hosts to drive host validation (within the endpoint and socket)
as well url generation (for views).



# Rough implementation description
In order to meet the objectives, the following things will have to be built:

* a plug to use within the endpoint that validates that we only serve if the
  hostname is allowed
* a custom socket transport which uses the dynamic configuration to check if
  the browser provided origin is one of the allowed hostnames
* a helper module for controllers/views which generates urls just like the
  default one but taking the dynamic configuration into account



# Implementation
The following has been built:

* `DingenWeb.DynamicOrigin`: entrypoint module for the dynamic origin
  functionality. Contains the function `origin_allowed?(origin)` which checks
  if the given origin (string) is contained within the storage (and hence is
  known).
* `DingenWeb.DynamicOrigin.Storage`: storage GenServer module which holds all
  currently allowed origins within an ETS table. It regularly polls the business
  logic for origins and updates it's table accordingly.
* `DingenWeb.DynamicOrigin.Plug`: Plug which can be added to the andpoint and
  calls `DingenWeb.DynamicOrigin` in order to check if the current request is
  allowed (scheme, host, port matches the allowed origins)
* `DingenWeb.DynamicOrigin.Router`: Module to be included within the router's
  definition. Causes a custom helpers module to be generated matching the
  router's specification. Those helpers are almost completely similar to those
  provided by default, with the exception, that they use request information
  to build absolute urls (which is now safe because we effectively have a
  dynamic whitelist)
* `DingenWeb.DynamicOrigin.Router.Helpers`: Module generating a helper module
  for the router it is used on (via `DingenWeb.DynamicOrigin.Router`). Basically
  the same helpers as generated by `Phoenix.Router.Helpers` but using the
  `@conn` struct's information for generating full urls instead of the endpoint
  configuration.



# Things that could be improved

* implement something like `current_url` for phoenix controllers (could be added
  to the generated custom helpers too)
* use pubsub for pushing allowed origin changes to the ets store and increase
  polling interval drastically
* make generated custom helpers usable with %Socket{} too (see next point)
* instead of checking in relevant modules if some properties of `conn` match an
  origin, introduce a %Site{} struct with one or more origins (and the current
  origin). Then, within the router, let the first plug lookup a Site based on
  origin. If the site could not be found, return an error as before. Otherwise,
  add the site to the (private) assigns of the conn.
  Then, let the custom transport and the helpers use the site information for
  further validation and url generation.
* due to private functions in `Plug.Conn` (such as `request_url_port`), some
  code duplication happens. Plug.Conn could have a helper module with all
  functions working on `%Plug.Conn` being public so that those could be used
  in other libraries too.
  Furthermore, there is no `request_origin` function (scheme + host + port;
  sans path and query) which could also be a nice addition.
